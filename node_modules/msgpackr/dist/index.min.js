(function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):(e=e||self,t(e.msgpackr={}))})(this,function(e){'use strict';var t=Math.floor;function n(){try{if(!D.trusted&&!Y){let e=M.sharedLength||0;e<M.length&&(M.length=e)}let e=r();if(B&&(// bundled strings to skip past
P=B.postBundlePosition),P==E)M.restoreStructures&&s(),M=null,R=null,C&&(C=null);else if(P>E)// over read
throw new Error("Unexpected end of MessagePack data");else if(!Y)throw new Error("Data read, but end of buffer not reached "+JSON.stringify(e).slice(0,100));// else more to read, but we are reading sequentially, so don't clear source yet
return e}catch(e){throw M.restoreStructures&&s(),m(),(e instanceof RangeError||e.message.startsWith("Unexpected end of buffer")||P>E)&&(e.incomplete=!0),e}}function s(){for(let e in M.restoreStructures)M[e]=M.restoreStructures[e];M.restoreStructures=null}function r(){let e=R[P++];if(160>e){if(!(128>e)){if(!(144>e)){e-=144;let t=Array(e);for(let n=0;n<e;n++)t[n]=r();return t}if(e-=128,D.mapsAsObjects){let t={};for(let n=0;n<e;n++)t[h()]=r();return t}else{let t=new Map;for(let n=0;n<e;n++)t.set(r(),r());return t}}else if(64>e)return e;else{let t=M[63&e]||D.getStructures&&o()[63&e];return t?(t.read||(t.read=i(t,63&e)),t.read()):e}}else if(192>e){// fixstr
let t=e-160;if(v>=P)return _.slice(P-F,(P+=t)-F);if(0==v&&140>E){// for small blocks, avoiding the overhead of the extract call is helpful
let e=16>t?g(t):c(t);if(null!=e)return e}return H(t)}else{let t;switch(e){case 192:return null;case 193:return B?(t=r(),0<t?B[1].slice(B.position1,B.position1+=t):B[0].slice(B.position0,B.position0-=t)):W;// "never-used", return special object to denote that
case 194:return!1;case 195:return!0;case 196:if(t=R[P++],void 0===t)throw new Error("Unexpected end of buffer");return p(t);case 197:return t=T.getUint16(P),P+=2,p(t);case 198:return t=T.getUint32(P),P+=4,p(t);case 199:// ext 8
return f(R[P++]);case 200:return t=T.getUint16(P),P+=2,f(t);case 201:return t=T.getUint32(P),P+=4,f(t);case 202:if(t=T.getFloat32(P),2<D.useFloat32){// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
let e=se[(127&R[P])<<1|R[P+1]>>7];return P+=4,(e*t+(0<t?.5:-.5)>>0)/e}return P+=4,t;case 203:return t=T.getFloat64(P),P+=8,t;// uint handlers
case 204:return R[P++];case 205:return t=T.getUint16(P),P+=2,t;case 206:return t=T.getUint32(P),P+=4,t;case 207:return D.int64AsNumber?(t=4294967296*T.getUint32(P),t+=T.getUint32(P+4)):t=T.getBigUint64(P),P+=8,t;// int handlers
case 208:return T.getInt8(P++);case 209:return t=T.getInt16(P),P+=2,t;case 210:return t=T.getInt32(P),P+=4,t;case 211:return D.int64AsNumber?(t=4294967296*T.getInt32(P),t+=T.getUint32(P+4)):t=T.getBigInt64(P),P+=8,t;case 212:if(t=R[P++],114==t)return ee(63&R[P++]);else{let e=j[t];if(e)return e.read?(P++,e.read(r())):e.noBuffer?(P++,e()):e(R.subarray(P,++P));throw new Error("Unknown extension "+t)}case 213:return t=R[P],114==t?(P++,ee(63&R[P++],R[P++])):f(2);case 214:// fixext 4
return f(4);case 215:// fixext 8
return f(8);case 216:// fixext 16
return f(16);case 217:return t=R[P++],v>=P?_.slice(P-F,(P+=t)-F):J(t);case 218:return t=T.getUint16(P),P+=2,v>=P?_.slice(P-F,(P+=t)-F):K(t);case 219:return t=T.getUint32(P),P+=4,v>=P?_.slice(P-F,(P+=t)-F):Q(t);case 220:return t=T.getUint16(P),P+=2,u(t);case 221:return t=T.getUint32(P),P+=4,u(t);case 222:return t=T.getUint16(P),P+=2,d(t);case 223:return t=T.getUint32(P),P+=4,d(t);default:// negative int
if(224<=e)return e-256;if(void 0===e){let e=new Error("Unexpected end of MessagePack data");throw e.incomplete=!0,e}throw new Error("Unknown MessagePack token "+e);}}}function i(e,t){function n(){// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function
if(n.count++>z){let n=e.read=new Function("r","return function(){return {"+e.map(e=>q.test(e)?e+":r()":"["+JSON.stringify(e)+"]:r()").join(",")+"}}")(r);return 0===e.highByte&&(e.read=G(t,e.read)),n();// second byte is already read, if there is one so immediately read object
}let s={};for(let t,n=0,i=e.length;n<i;n++)t=e[n],s[t]=r();return s}return n.count=0,0===e.highByte?G(t,n):n}function o(){let e=y(()=>(R=null,D.getStructures()));return M=D._mergeStructures(e,M)}function a(e){let t;if(16>e&&(t=g(e)))return t;if(64<e&&L)return L.decode(R.subarray(P,P+=e));const n=P+e,s=[];for(t="";P<n;){const e=R[P++];if(0==(128&e))s.push(e);else if(192==(224&e)){// 2 bytes
const t=63&R[P++];s.push((31&e)<<6|t)}else if(224==(240&e)){// 3 bytes
const t=63&R[P++],n=63&R[P++];s.push((31&e)<<12|t<<6|n)}else if(240==(248&e)){// 4 bytes
const t=63&R[P++],n=63&R[P++],r=63&R[P++];let i=(7&e)<<18|t<<12|n<<6|r;65535<i&&(i-=65536,s.push(55296|1023&i>>>10),i=56320|1023&i),s.push(i)}else s.push(e);4096<=s.length&&(t+=X.apply(String,s),s.length=0)}return 0<s.length&&(t+=X.apply(String,s)),t}function u(e){let t=Array(e);for(let n=0;n<e;n++)t[n]=r();return t}function d(e){if(D.mapsAsObjects){let t={};for(let n=0;n<e;n++)t[h()]=r();return t}else{let t=new Map;for(let n=0;n<e;n++)t.set(r(),r());return t}}function c(e){let t=P,n=Array(e);for(let s=0;s<e;s++){const e=R[P++];if(0<(128&e))return void(P=t);n[s]=e}return X.apply(String,n)}function g(t){if(4>t){if(!(2>t)){let e=R[P++],n=R[P++];if(0<(128&e)||0<(128&n))return void(P-=2);if(3>t)return X(e,n);let s=R[P++];return 0<(128&s)?void(P-=3):X(e,n,s)}if(0===t)return"";else{let e=R[P++];return 1<(128&e)?void(P-=1):X(e)}}else{let s=R[P++],r=R[P++],a=R[P++],u=R[P++];if(0<(128&s)||0<(128&r)||0<(128&a)||0<(128&u))return void(P-=4);if(6>t){if(4===t)return X(s,r,a,u);else{let t=R[P++];return 0<(128&t)?void(P-=5):X(s,r,a,u,t)}}else if(8>t){let n=R[P++],e=R[P++];if(0<(128&n)||0<(128&e))return void(P-=6);if(7>t)return X(s,r,a,u,n,e);let i=R[P++];return 0<(128&i)?void(P-=7):X(s,r,a,u,n,e,i)}else{let d=R[P++],e=R[P++],c=R[P++],g=R[P++];if(0<(128&d)||0<(128&e)||0<(128&c)||0<(128&g))return void(P-=8);if(10>t){if(8===t)return X(s,r,a,u,d,e,c,g);else{let t=R[P++];return 0<(128&t)?void(P-=9):X(s,r,a,u,d,e,c,g,t)}}else if(12>t){let n=R[P++],i=R[P++];if(0<(128&n)||0<(128&i))return void(P-=10);if(11>t)return X(s,r,a,u,d,e,c,g,n,i);let o=R[P++];return 0<(128&o)?void(P-=11):X(s,r,a,u,d,e,c,g,n,i,o)}else{let p=R[P++],i=R[P++],f=R[P++],h=R[P++];if(0<(128&p)||0<(128&i)||0<(128&f)||0<(128&h))return void(P-=12);if(!(14>t)){let l=R[P++],y=R[P++];if(0<(128&l)||0<(128&y))return void(P-=14);if(15>t)return X(s,r,a,u,d,e,c,g,p,i,f,h,l,y);let n=R[P++];return 0<(128&n)?void(P-=15):X(s,r,a,u,d,e,c,g,p,i,f,h,l,y,n)}if(12===t)return X(s,r,a,u,d,e,c,g,p,i,f,h);else{let t=R[P++];return 0<(128&t)?void(P-=13):X(s,r,a,u,d,e,c,g,p,i,f,h,t)}}}}}function l(){let e,t=R[P++];if(192>t)// fixstr
e=t-160;else switch(t){case 217:e=R[P++];break;case 218:e=T.getUint16(P),P+=2;break;case 219:e=T.getUint32(P),P+=4;break;default:throw new Error("Expected string");}return a(e)}function p(e){return D.copyBuffers?// specifically use the copying slice (not the node one)
Uint8Array.prototype.slice.call(R,P,P+=e):R.subarray(P,P+=e)}function f(e){let t=R[P++];if(j[t])return j[t](R.subarray(P,P+=e));throw new Error("Unknown extension type "+t)}function h(){let e=R[P++];if(160<=e&&192>e){if(e-=160,v>=P)// if it has been extracted, must use it (and faster anyway)
return _.slice(P-F,(P+=e)-F);if(!(0==v&&180>E))return H(e)}else return P--,r();let t,n=4095&(e<<5^(1<e?T.getUint16(P):0<e?R[P]:0)),s=Z[n],o=P,a=P+e-3,u=0;if(s&&s.bytes==e){for(;o<a;){if(t=T.getUint32(o),t!=s[u++]){o=1879048192;break}o+=4}for(a+=3;o<a;)if(t=R[o++],t!=s[u++]){o=1879048192;break}if(o===a)return P=o,s.string;a-=3,o=P}for(s=[],Z[n]=s,s.bytes=e;o<a;)t=T.getUint32(o),s.push(t),o+=4;for(a+=3;o<a;)t=R[o++],s.push(t);// for small blocks, avoiding the overhead of the extract call is helpful
let d=16>e?g(e):c(e);return null==d?s.string=H(e):s.string=d}// the registration of the record definition extension (as "r")
// notepack defines extension 0 to mean undefined, so use that as the default here
// registration of bulk record definition?
// currentExtensions[0x52] = () =>
function y(e){let t=E,n=P,s=F,r=v,i=_,o=C,a=B,u=new Uint8Array(R.slice(0,E)),d=M,c=M.slice(0,M.length),g=D,l=Y,p=e();return E=t,P=n,F=s,v=r,_=i,C=o,B=a,R=u,Y=l,M=d,M.splice(0,M.length,...c),D=g,T=new DataView(R.buffer,R.byteOffset,R.byteLength),p}function m(){R=null,C=null,M=null}function b(e){j[e.type]=e.unpack?e.unpack:e}function U(e,t,n){let s=e.byteLength;if(256>s+1){var{target:r,position:i}=n(4+s);r[i++]=199,r[i++]=s+1}else if(65536>s+1){var{target:r,position:i}=n(5+s);r[i++]=200,r[i++]=s+1>>8,r[i++]=255&s+1}else{var{target:r,position:i,targetView:o}=n(7+s);// plus one for the type byte
r[i++]=201,o.setUint32(i,s+1),i+=4}// "t" for typed array
r[i++]=116,r[i++]=t,r.set(new Uint8Array(e.buffer,e.byteOffset,e.byteLength),i)}function k(e,t){let n=e.byteLength;var s,r;if(256>n){var{target:s,position:r}=t(n+2);s[r++]=196,s[r++]=n}else if(65536>n){var{target:s,position:r}=t(n+3);s[r++]=197,s[r++]=n>>8,s[r++]=255&n}else{var{target:s,position:r,targetView:i}=t(n+5);s[r++]=198,i.setUint32(r,n),r+=4}s.set(e,r)}function I(e,t,n,s){let r=e.length;return 1===r?t[n++]=212:2===r?t[n++]=213:4===r?t[n++]=214:8===r?t[n++]=215:16===r?t[n++]=216:256>r?(t[n++]=199,t[n++]=r):65536>r?(t[n++]=200,t[n++]=r>>8,t[n++]=255&r):(t[n++]=201,t[n++]=r>>24,t[n++]=255&r>>16,t[n++]=255&r>>8,t[n++]=255&r),t[n++]=s,t.set(e,n),n+=r,n}function S(e,t){// insert the ids that need to be referenced for structured clones
let n,s=6*t.length,r=e.length-s;for(t.sort((e,t)=>e.offset>t.offset?1:-1);n=t.pop();){let t=n.offset,i=n.id;e.copyWithin(t+s,t,r),s-=6;let o=t+s;// 'i'
e[o++]=214,e[o++]=105,e[o++]=i>>24,e[o++]=255&i>>16,e[o++]=255&i>>8,e[o++]=255&i,r=t}return e}function O(e,t){ke.setUint32(Oe.position+e,Se-Oe.position-e);let n=Oe;Oe=null,t(n[0]),t(n[1])}function A(e){if(e.Class){if(!e.pack&&!e.write)throw new Error("Extension has no pack or write function");if(e.pack&&!e.type)throw new Error("Extension has no type (numeric code to identify the extension)");pe.unshift(e.Class),le.unshift(e)}b(e)}function*w(e,t){const n=new we(t);for(const s of e)yield n.pack(s)}async function*x(e,t){const n=new we(t);for await(const s of e)yield n.pack(s)}/**
	 * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects
	 * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.
	 * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator
	 * @param {object} [options] - unpackr options
	 * @returns {IterableIterator|Promise.<AsyncIterableIterator}
	 */var L;try{L=new TextDecoder}catch(e){}var R,E,M,_,B,C,T,P=0,D={},F=0,v=0,j=[],N={useRecords:!1,mapsAsObjects:!0};class V{}const W=new V;W.name="MessagePack 0xC1";var Y=!1,z=2;try{new Function("")}catch(e){// if eval variants are not supported, do not create inline object readers ever
z=1/0}class ${constructor(e){e&&(!1===e.useRecords&&e.mapsAsObjects===void 0&&(e.mapsAsObjects=!0),e.structures?e.structures.sharedLength=e.structures.length:e.getStructures&&((e.structures=[]).uninitialized=!0,e.structures.sharedLength=0)),Object.assign(this,e)}unpack(e,t){if(R)// re-entrant execution, save the state and restore it after we do this unpack
return y(()=>(m(),this?this.unpack(e,t):$.prototype.unpack.call(N,e,t)));E=-1<t?t:e.length,P=0,v=0,_=null,B=null,R=e;// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend
// technique for getting data from a database where it can be copied into an existing buffer instead of creating
// new ones
try{T=e.dataView||(e.dataView=new DataView(e.buffer,e.byteOffset,e.byteLength))}catch(t){if(R=null,e instanceof Uint8Array)throw t;throw new Error("Source must be a Uint8Array or Buffer but was a "+(e&&"object"==typeof e?e.constructor.name:typeof e))}if(this instanceof $){if(D=this,this.structures)return M=this.structures,n();(!M||0<M.length)&&(M=[])}else D=N,(!M||0<M.length)&&(M=[]);return n()}unpackMultiple(e,t){let s,r=0;try{Y=!0;let i=e.length,o=this?this.unpack(e,i):re.unpack(e,i);if(t){for(t(o);P<i;)if(r=P,!1===t(n()))return;}else{for(s=[o];P<i;)r=P,s.push(n());return s}}catch(e){throw e.lastPosition=r,e.values=s,e}finally{Y=!1,m()}}_mergeStructures(e,t){e=e||[];for(let n,s=0,r=e.length;s<r;s++)n=e[s],n&&(n.isShared=!0,32<=s&&(n.highByte=s-32>>5));for(let n in e.sharedLength=e.length,t||[])if(0<=n){let s=e[n],r=t[n];r&&(s&&((e.restoreStructures||(e.restoreStructures=[]))[n]=s),e[n]=r)}return this.structures=e}decode(e,t){return this.unpack(e,t)}}const q=/^[a-zA-Z_$][a-zA-Z\d_$]*$/,G=(e,t)=>function(){let n=R[P++];if(0===n)return t();let s=32>e?-(e+(n<<5)):e+(n<<5),r=M[s]||o()[s];if(!r)throw new Error("Record id is not defined for "+s);return r.read||(r.read=i(r,e)),r.read()};var H=a,J=a,K=a,Q=a;var X=String.fromCharCode,Z=Array(4096);const ee=(e,t)=>{var n=r();let s=e;void 0!==t&&(e=32>e?-((t<<5)+e):(t<<5)+e,n.highByte=t);let o=M[e];return o&&o.isShared&&((M.restoreStructures||(M.restoreStructures=[]))[e]=o),M[e]=n,n.read=i(n,s),n.read()};j[0]=()=>{},j[0].noBuffer=!0,j[101]=()=>{let e=r();return(globalThis[e[0]]||Error)(e[1])},j[105]=()=>{// id extension (for structured clones)
let e=T.getUint32(P-4);C||(C=new Map);let t,n=R[P];t=144<=n&&160>n||220==n||221==n?[]:{};let s={target:t};// a placeholder object
C.set(e,s);let i=r();// read the next value as the target object to id
return s.used?Object.assign(t,i):(s.target=i,i);// no cycle, can just use the returned read object
},j[112]=()=>{// pointer extension (for structured clones)
let e=T.getUint32(P-4),t=C.get(e);return t.used=!0,t.target},j[115]=()=>new Set(r());const te=["Int8","Uint8","Uint8Clamped","Int16","Uint16","Int32","Uint32","Float32","Float64","BigInt64","BigUint64"].map(e=>e+"Array");j[116]=e=>{let t=e[0],n=te[t];if(!n)throw new Error("Could not find typed array for code "+t);// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned
return new globalThis[n](Uint8Array.prototype.slice.call(e,1).buffer)},j[120]=()=>{let e=r();return new RegExp(e[0],e[1])};const ne=[];j[98]=e=>{let t=(e[0]<<24)+(e[1]<<16)+(e[2]<<8)+e[3],n=P;return P+=t-e.length,B=ne,B=[l(),l()],B.position0=0,B.position1=0,B.postBundlePosition=P,P=n,r()},j[255]=e=>4==e.length?new Date(1e3*(16777216*e[0]+(e[1]<<16)+(e[2]<<8)+e[3])):8==e.length?new Date(((e[0]<<22)+(e[1]<<14)+(e[2]<<6)+(e[3]>>2))/1e6+1e3*(4294967296*(3&e[3])+16777216*e[4]+(e[5]<<16)+(e[6]<<8)+e[7])):12==e.length?new Date(((e[0]<<24)+(e[1]<<16)+(e[2]<<8)+e[3])/1e6+1e3*((128&e[4]?-281474976710656:0)+1099511627776*e[6]+4294967296*e[7]+16777216*e[8]+(e[9]<<16)+(e[10]<<8)+e[11])):new Date("invalid");const se=Array(147);// this is a table matching binary exponents to the multiplier to determine significant digit rounding
for(let n=0;256>n;n++)se[n]=+("1e"+t(45.15-.30103*n));var re=new $({useRecords:!1});const ie=re.unpack,oe=re.unpackMultiple,ae=re.unpack,ue={NEVER:0,ALWAYS:1,DECIMAL_ROUND:3,DECIMAL_FIT:4};let de,ce=new Float32Array(1),ge=new Uint8Array(ce.buffer,0,4);try{de=new TextEncoder}catch(e){}let le,pe;const fe="undefined"!=typeof Buffer,he=fe?function(e){return Buffer.allocUnsafeSlow(e)}:Uint8Array,ye=fe?Buffer:Uint8Array,me=fe?4294967296:2144337920;let be,Ue,ke,Ie,Se=0,Oe=null;const Ae=Symbol("record-id");class we extends ${constructor(e){super(e),this.offset=0;let t,n,s,r,i=0,o=ye.prototype.utf8Write?function(e,t){return be.utf8Write(e,t,4294967295)}:!!(de&&de.encodeInto)&&function(e,t){return de.encodeInto(e,be.subarray(t)).written},a=this;e||(e={});let u=e&&e.sequential,d=e.structures||e.saveStructures,c=e.maxSharedStructures;if(null==c&&(c=d?32:0),8160<c)throw new Error("Maximum maxSharedStructure is 8160");e.structuredClone&&null==e.moreTypes&&(e.moreTypes=!0);let g=e.maxOwnStructures;null==g&&(g=d?32:64),this.structures||!1==e.useRecords||(this.structures=[]);// two byte record ids for shared structures
let l=32<c||64<g+c,p=c+64,f=c+g+64;if(8256<f)throw new Error("Maximum maxSharedStructure + maxOwnStructure is 8192");let h=[],y=0,m=0;this.pack=this.encode=function(e,o){if(be||(be=new he(8192),ke=new DataView(be.buffer,0,8192),Se=0),Ie=be.length-10,2048>Ie-Se?(be=new he(be.length),ke=new DataView(be.buffer,0,be.length),Ie=be.length-10,Se=0):Se=2147483640&Se+7,t=Se,r=a.structuredClone?new Map:null,a.bundleStrings&&"string"!=typeof e?(Oe=[],Oe.size=1/0):Oe=null,s=a.structures,s){s.uninitialized&&(s=a._mergeStructures(a.getStructures()));let e=s.sharedLength||0;if(e>c)//if (maxSharedStructures <= 32 && structures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids
throw new Error("Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to "+s.sharedLength);if(!s.transitions){s.transitions=Object.create(null);for(let t,n=0;n<e;n++){if(t=s[n],!t)continue;let e,r=s.transitions;for(let n,s=0,i=t.length;s<i;s++)n=t[s],e=r[n],e||(e=r[n]=Object.create(null)),r=e;r[Ae]=n+64}i=e}u||(s.nextId=e+64)}n&&(n=!1);try{// update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially
if(b(e),Oe&&O(t,b),a.offset=Se,r&&r.idsToInsert){Se+=6*r.idsToInsert.length,Se>Ie&&k(Se),a.offset=Se;let e=S(be.subarray(t,Se),r.idsToInsert);return r=null,e}return o&Ce?(be.start=t,be.end=Se,be):be.subarray(t,Se);// position can change if we call pack again in saveStructures, so we get the buffer now
}finally{if(s){10>m&&m++;let r=s.sharedLength||c;if(s.length>r&&(s.length=r),1e4<y)s.transitions=null,m=0,y=0,0<h.length&&(h=[]);else if(0<h.length&&!u){for(let e=0,t=h.length;e<t;e++)h[e][Ae]=0;h=[]}if(n&&a.saveStructures){// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save
let n=be.subarray(t,Se);return!1===a.saveStructures(s,i)?(a._mergeStructures(a.getStructures()),a.pack(e)):(i=r,n)}}o&Te&&(Se=t)}};const b=e=>{Se>Ie&&(be=k(Se));var n,s=typeof e;if("string"==s){let s=e.length;if(Oe&&4<=s&&4096>s){if((Oe.size+=s)>61440){let e,n=(Oe[0]?3*Oe[0].length+Oe[1].length:0)+10;Se+n>Ie&&(be=k(Se+n)),Oe.position?(be[Se]=200,Se+=3,be[Se++]=98,e=Se-t,Se+=4,O(t,b),ke.setUint16(e+t-3,Se-t-e)):(be[Se++]=214,be[Se++]=98,e=Se-t,Se+=4),Oe=["",""],Oe.size=0,Oe.position=e}let n=/[\u0080-\uFFFF]/.test(e);return Oe[n?0:1]+=e,be[Se++]=193,void b(n?-s:s)}let r=32>s?1:256>s?2:65536>s?3:5;// first we estimate the header size, so we can write to the correct location
let i=3*s;if(Se+i>Ie&&(be=k(Se+i)),64>s||!o){let t,i,o,a=Se+r;for(t=0;t<s;t++)i=e.charCodeAt(t),128>i?be[a++]=i:2048>i?(be[a++]=192|i>>6,be[a++]=128|63&i):55296==(64512&i)&&56320==(64512&(o=e.charCodeAt(t+1)))?(i=65536+((1023&i)<<10)+(1023&o),t++,be[a++]=240|i>>18,be[a++]=128|63&i>>12,be[a++]=128|63&i>>6,be[a++]=128|63&i):(be[a++]=224|i>>12,be[a++]=128|63&i>>6,be[a++]=128|63&i);n=a-Se-r}else n=o(e,Se+r);32>n?be[Se++]=160|n:256>n?(2>r&&be.copyWithin(Se+2,Se+1,Se+1+n),be[Se++]=217,be[Se++]=n):65536>n?(3>r&&be.copyWithin(Se+3,Se+2,Se+2+n),be[Se++]=218,be[Se++]=n>>8,be[Se++]=255&n):(5>r&&be.copyWithin(Se+5,Se+3,Se+3+n),be[Se++]=219,ke.setUint32(Se,n),Se+=4),Se+=n}else if("number"===s){if(e>>>0===e)64>e?be[Se++]=e:256>e?(be[Se++]=204,be[Se++]=e):65536>e?(be[Se++]=205,be[Se++]=e>>8,be[Se++]=255&e):(be[Se++]=206,ke.setUint32(Se,e),Se+=4);else if(e>>0===e)-32<=e?be[Se++]=256+e:-128<=e?(be[Se++]=208,be[Se++]=e+256):-32768<=e?(be[Se++]=209,ke.setInt16(Se,e),Se+=2):(be[Se++]=210,ke.setInt32(Se,e),Se+=4);else{let t;if(0<(t=this.useFloat32)&&4294967296>e&&-2147483648<=e){be[Se++]=202,ke.setFloat32(Se,e);let n;if(4>t||// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved
(n=e*se[(127&be[Se])<<1|be[Se+1]>>7])>>0===n)return void(Se+=4);// move back into position for writing a double
Se--}be[Se++]=203,ke.setFloat64(Se,e),Se+=8}}else if("object"===s){if(!e)be[Se++]=192;else{if(r){let n=r.get(e);if(n){if(!n.id){let e=r.idsToInsert||(r.idsToInsert=[]);n.id=e.push(n)}return be[Se++]=214,be[Se++]=112,ke.setUint32(Se,n.id),void(Se+=4)}r.set(e,{offset:Se-t})}let s=e.constructor;if(s===Object)U(e,!0);else if(s===Array){n=e.length,16>n?be[Se++]=144|n:65536>n?(be[Se++]=220,be[Se++]=n>>8,be[Se++]=255&n):(be[Se++]=221,ke.setUint32(Se,n),Se+=4);for(let t=0;t<n;t++)b(e[t])}else if(s===Map){n=e.size,16>n?be[Se++]=128|n:65536>n?(be[Se++]=222,be[Se++]=n>>8,be[Se++]=255&n):(be[Se++]=223,ke.setUint32(Se,n),Se+=4);for(let[t,n]of e)b(t),b(n)}else{for(let t,n=0,s=le.length;n<s;n++)if(t=pe[n],e instanceof t){let t=le[n];if(t.write)return t.type&&(be[Se++]=212,be[Se++]=t.type,be[Se++]=0),void b(t.write.call(this,e));let s=be,r=ke,i=Se;be=null;let o;try{o=t.pack.call(this,e,e=>(be=s,s=null,Se+=e,Se>Ie&&k(Se),{target:be,targetView:ke,position:Se-e}),b)}finally{s&&(be=s,ke=r,Se=i,Ie=be.length-10)}return void(o&&(o.length+Se>Ie&&k(o.length+Se),Se=I(o,be,Se,t.type)))}// no extension found, write as object
U(e,!e.hasOwnProperty)}}}else if("boolean"===s)be[Se++]=e?195:194;else if("bigint"===s){if(e<BigInt(1)<<BigInt(63)&&e>=-(BigInt(1)<<BigInt(63)))be[Se++]=211,ke.setBigInt64(Se,e);else if(e<BigInt(1)<<BigInt(64)&&0<e)be[Se++]=207,ke.setBigUint64(Se,e);else// overflow
if(this.largeBigIntToFloat)be[Se++]=203,ke.setFloat64(Se,+e);else throw new RangeError(e+" was too large to fit in MessagePack 64-bit integer format, set largeBigIntToFloat to convert to float-64");Se+=8}else if("undefined"===s)this.encodeUndefinedAsNil?be[Se++]=192:(be[Se++]=212,be[Se++]=0,be[Se++]=0);else if("function"===s)b(this.writeFunction&&this.writeFunction());else throw new Error("Unknown type: "+s)},U=!1===this.useRecords?this.variableMapSize?e=>{// this method is slightly slower, but generates "preferred serialization" (optimally small for smaller objects)
let t=Object.keys(e),n=t.length;16>n?be[Se++]=128|n:65536>n?(be[Se++]=222,be[Se++]=n>>8,be[Se++]=255&n):(be[Se++]=223,ke.setUint32(Se,n),Se+=4);let s;for(let r=0;r<n;r++)b(s=t[r]),b(e[s])}:(e,n)=>{be[Se++]=222;// always using map 16, so we can preallocate and set the length afterwards
let s=Se-t;Se+=2;let r=0;for(let t in e)(n||e.hasOwnProperty(t))&&(b(t),b(e[t]),r++);be[s++ +t]=r>>8,be[s+t]=255&r}:e.progressiveRecords&&!l?// this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)
(e,n)=>{let r,i,o=s.transitions||(s.transitions=Object.create(null)),a=Se++-t;for(let u in e)if(n||e.hasOwnProperty(u)){if(r=o[u],r)o=r;else{// record doesn't exist, create full new record and insert it
let n=Object.keys(e),d=o;o=s.transitions;let c=0;for(let e,t=0,s=n.length;t<s;t++)e=n[t],r=o[e],r||(r=o[e]=Object.create(null),c++),o=r;a+t+1==Se?(Se--,A(o,n,c)):// otherwise we need to insert the record, moving existing data after the record
w(o,n,a,c),i=!0,o=d[u]}b(e[u])}if(!i){let n=o[Ae];n?be[a+t]=n:w(o,Object.keys(e),a,0)}}:(e,t)=>{let n,r=s.transitions||(s.transitions=Object.create(null)),i=0;for(let s in e)(t||e.hasOwnProperty(s))&&(n=r[s],n||(n=r[s]=Object.create(null),i++),r=n);let o=r[Ae];// now write the values
for(let n in o?96<=o&&l?(be[Se++]=(31&(o-=96))+96,be[Se++]=o>>5):be[Se++]=o:A(r,r.__keys__||Object.keys(e),i),e)(t||e.hasOwnProperty(n))&&b(e[n])},k=e=>{var n=Math.min,s=Math.round,r=Math.max;let i;if(16777216<e){// special handling for really large buffers
if(e-t>me)throw new Error("Packed buffer would be larger than maximum buffer size");i=n(me,4096*s(r((e-t)*(67108864<e?1.25:2),4194304)/4096))}else// faster handling for smaller buffers
i=(r(e-t<<2,be.length-1)>>12)+1<<12;let o=new he(i);return ke=new DataView(o.buffer,0,i),e=n(e,be.length),be.copy?be.copy(o,0,t,e):o.set(be.slice(t,e)),Se-=t,t=0,Ie=o.length-10,be=o},A=(e,t,r)=>{let i=s.nextId;i||(i=64),i<p&&this.shouldShareStructure&&!this.shouldShareStructure(t)?(i=s.nextOwnId,!(i<f)&&(i=p),s.nextOwnId=i+1):(i>=f&&(// cycle back around
i=p),s.nextId=i+1);let o=t.highByte=96<=i&&l?i-96>>5:-1;e[Ae]=i,e.__keys__=t,s[i-64]=t,i<p?(t.isShared=!0,s.sharedLength=i-63,n=!0,0<=o?(be[Se++]=(31&i)+96,be[Se++]=o):be[Se++]=i):(0<=o?(be[Se++]=213,be[Se++]=114,be[Se++]=(31&i)+96,be[Se++]=o):(be[Se++]=212,be[Se++]=114,be[Se++]=i),r&&(y+=m*r),h.length>=g&&(h.shift()[Ae]=0),h.push(e),b(t))},w=(e,n,s,r)=>{let i=be,o=Se,a=Ie,u=t;be=Ue,Se=0,t=0,be||(Ue=be=new he(8192)),Ie=be.length-10,A(e,n,r),Ue=be;let d=Se;if(be=i,Se=o,Ie=a,t=u,1<d){let e=Se+d-1;e>Ie&&k(e);let n=s+t;be.copyWithin(n+d,n+1,Se),be.set(Ue.slice(0,d),n),Se=e}else be[s+t]=Ue[0]}}useBuffer(e){// this means we are finished using our own buffer and we can write over it safely
be=e,ke=new DataView(be.buffer,be.byteOffset,be.byteLength),Se=0}clearSharedData(){this.structures&&(this.structures=[])}}pe=[Date,Set,Error,RegExp,ArrayBuffer,Object.getPrototypeOf(Uint8Array.prototype).constructor/*TypedArray*/,V],le=[{pack(e,n,s){let r=e.getTime()/1e3;if((this.useTimestamp32||0===e.getMilliseconds())&&0<=r&&4294967296>r){// Timestamp 32
let{target:e,targetView:t,position:s}=n(6);e[s++]=214,e[s++]=255,t.setUint32(s,r)}else if(0<r&&4294967296>r){// Timestamp 64
let{target:t,targetView:s,position:i}=n(10);t[i++]=215,t[i++]=255,s.setUint32(i,4e6*e.getMilliseconds()+(r/1e3/4294967296>>0)),s.setUint32(i+4,r)}else if(isNaN(r)){if(this.onInvalidDate)return n(0),s(this.onInvalidDate());// Intentionally invalid timestamp
let{target:e,targetView:t,position:r}=n(3);e[r++]=212,e[r++]=255,e[r++]=255}else{// Timestamp 96
let{target:s,targetView:i,position:o}=n(15);s[o++]=199,s[o++]=12,s[o++]=255,i.setUint32(o,1e6*e.getMilliseconds()),i.setBigInt64(o+4,BigInt(t(r)))}}},{pack(e,t,n){let s=Array.from(e),{target:r,position:i}=t(this.moreTypes?3:0);this.moreTypes&&(r[i++]=212,r[i++]=115,r[i++]=0),n(s)}},{pack(e,t,n){let{target:s,position:r}=t(this.moreTypes?3:0);this.moreTypes&&(s[r++]=212,s[r++]=101,s[r++]=0),n([e.name,e.message])}},{pack(e,t,n){let{target:s,position:r}=t(this.moreTypes?3:0);this.moreTypes&&(s[r++]=212,s[r++]=120,s[r++]=0),n([e.source,e.flags])}},{pack(e,t){this.moreTypes?U(e,16,t):k(fe?Buffer.from(e):new Uint8Array(e),t)}},{pack(e,t){let n=e.constructor;n!==ye&&this.moreTypes?U(e,te.indexOf(n.name),t):k(e,t)}},{pack(e,t){// specific 0xC1 object
let{target:n,position:s}=t(1);n[s]=193}}];let xe=new we({useRecords:!1});const Le=xe.pack,Re=xe.pack,{NEVER:Ee,ALWAYS:Me,DECIMAL_ROUND:_e,DECIMAL_FIT:Be}=ue,Ce=512,Te=1024;e.ALWAYS=Me,e.C1=W,e.DECIMAL_FIT=Be,e.DECIMAL_ROUND=_e,e.Decoder=$,e.Encoder=we,e.FLOAT32_OPTIONS=ue,e.NEVER=Ee,e.Packr=we,e.REUSE_BUFFER_MODE=Ce,e.Unpackr=$,e.addExtension=A,e.clearSource=m,e.decode=ae,e.decodeIter=function(e,t={}){if(!e||"object"!=typeof e)throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise");const n=new $(t);let s;const r=e=>{let t;// if there's incomplete data from previous chunk, concatinate and try again
s&&(e=Buffer.concat([s,e]),s=void 0);try{t=n.unpackMultiple(e)}catch(n){if(n.incomplete)s=e.slice(n.lastPosition),t=n.values;else throw n}return t};if("function"==typeof e[Symbol.iterator])return function*(){for(const t of e)yield*r(t)}();return"function"==typeof e[Symbol.asyncIterator]?async function*(){for await(const t of e)yield*r(t)}():void 0},e.encode=Re,e.encodeIter=/**
	 * Given an Iterable first argument, returns an Iterable where each value is packed as a Buffer
	 * If the argument is only Async Iterable, the return value will be an Async Iterable.
	 * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object
	 * @param {options} [options] - msgpackr pack options
	 * @returns {IterableIterator|Promise.<AsyncIterableIterator>}
	 */function(e,t={}){if(!e||"object"!=typeof e)throw new Error("first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable");else{if("function"==typeof e[Symbol.iterator])return w(e,t);if("function"==typeof e.then||"function"==typeof e[Symbol.asyncIterator])return x(e,t);throw new Error("first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise")}},e.isNativeAccelerationEnabled=!1,e.mapsAsObjects=!0,e.pack=Le,e.roundFloat32=function(e){ce[0]=e;let t=se[(127&ge[3])<<1|ge[2]>>7];return(t*e+(0<e?.5:-.5)>>0)/t},e.unpack=ie,e.unpackMultiple=oe,e.useRecords=!1,Object.defineProperty(e,"__esModule",{value:!0})});
